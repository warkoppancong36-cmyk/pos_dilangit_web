import{a2 as C,a3 as A,r as b,V as H,aI as T}from"./main-D0MmhKIS.js";import{a as j,w as D}from"./index-D-EbNoF1.js";class F extends Error{constructor(r,t){super(r,t),this.name="FetchError",t!=null&&t.cause&&!this.cause&&(this.cause=t.cause)}}function _(o){var u,h,e,y,w;const r=((u=o.error)==null?void 0:u.message)||((h=o.error)==null?void 0:h.toString())||"",t=((e=o.request)==null?void 0:e.method)||((y=o.options)==null?void 0:y.method)||"GET",d=((w=o.request)==null?void 0:w.url)||String(o.request)||"/",f=`[${t}] ${JSON.stringify(d)}`,c=o.response?`${o.response.status} ${o.response.statusText}`:"<no response>",m=`${f}: ${c}${r?` ${r}`:""}`,a=new F(m,o.error?{cause:o.error}:void 0);for(const p of["request","options","response"])Object.defineProperty(a,p,{get(){return o[p]}});for(const[p,g]of[["data","_data"],["status","status"],["statusCode","status"],["statusText","statusText"],["statusMessage","statusText"]])Object.defineProperty(a,p,{get(){return o.response&&o.response[g]}});return a}const B=new Set(Object.freeze(["PATCH","POST","PUT","DELETE"]));function v(o="GET"){return B.has(o.toUpperCase())}function O(o){if(o===void 0)return!1;const r=typeof o;return r==="string"||r==="number"||r==="boolean"||r===null?!0:r!=="object"?!1:Array.isArray(o)?!0:o.buffer?!1:o.constructor&&o.constructor.name==="Object"||typeof o.toJSON=="function"}const U=new Set(["image/svg","application/xml","application/xhtml","application/html"]),N=/^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;function z(o=""){if(!o)return"json";const r=o.split(";").shift()||"";return N.test(r)?"json":U.has(r)||r.startsWith("text/")?"text":"blob"}function I(o,r,t,d){const f=M((r==null?void 0:r.headers)??(o==null?void 0:o.headers),t==null?void 0:t.headers,d);let c;return(t!=null&&t.query||t!=null&&t.params||r!=null&&r.params||r!=null&&r.query)&&(c={...t==null?void 0:t.params,...t==null?void 0:t.query,...r==null?void 0:r.params,...r==null?void 0:r.query}),{...t,...r,query:c,params:c,headers:f}}function M(o,r,t){if(!r)return new t(o);const d=new t(r);if(o)for(const[f,c]of Symbol.iterator in o||Array.isArray(o)?o:new t(o))d.set(f,c);return d}async function S(o,r){if(r)if(Array.isArray(r))for(const t of r)await t(o);else await r(o)}const J=new Set([408,409,425,429,500,502,503,504]),L=new Set([101,204,205,304]);function q(o={}){const{fetch:r=globalThis.fetch,Headers:t=globalThis.Headers,AbortController:d=globalThis.AbortController}=o;async function f(a){const u=a.error&&a.error.name==="AbortError"&&!a.options.timeout||!1;if(a.options.retry!==!1&&!u){let e;typeof a.options.retry=="number"?e=a.options.retry:e=v(a.options.method)?0:1;const y=a.response&&a.response.status||500;if(e>0&&(Array.isArray(a.options.retryStatusCodes)?a.options.retryStatusCodes.includes(y):J.has(y))){const w=typeof a.options.retryDelay=="function"?a.options.retryDelay(a):a.options.retryDelay||0;return w>0&&await new Promise(p=>setTimeout(p,w)),c(a.request,{...a.options,retry:e-1})}}const h=_(a);throw Error.captureStackTrace&&Error.captureStackTrace(h,c),h}const c=async function(u,h={}){const e={request:u,options:I(u,h,o.defaults,t),response:void 0,error:void 0};e.options.method&&(e.options.method=e.options.method.toUpperCase()),e.options.onRequest&&await S(e,e.options.onRequest),typeof e.request=="string"&&(e.options.baseURL&&(e.request=j(e.request,e.options.baseURL)),e.options.query&&(e.request=D(e.request,e.options.query),delete e.options.query),"query"in e.options&&delete e.options.query,"params"in e.options&&delete e.options.params),e.options.body&&v(e.options.method)&&(O(e.options.body)?(e.options.body=typeof e.options.body=="string"?e.options.body:JSON.stringify(e.options.body),e.options.headers=new t(e.options.headers||{}),e.options.headers.has("content-type")||e.options.headers.set("content-type","application/json"),e.options.headers.has("accept")||e.options.headers.set("accept","application/json")):("pipeTo"in e.options.body&&typeof e.options.body.pipeTo=="function"||typeof e.options.body.pipe=="function")&&("duplex"in e.options||(e.options.duplex="half")));let y;if(!e.options.signal&&e.options.timeout){const p=new d;y=setTimeout(()=>{const g=new Error("[TimeoutError]: The operation was aborted due to timeout");g.name="TimeoutError",g.code=23,p.abort(g)},e.options.timeout),e.options.signal=p.signal}try{e.response=await r(e.request,e.options)}catch(p){return e.error=p,e.options.onRequestError&&await S(e,e.options.onRequestError),await f(e)}finally{y&&clearTimeout(y)}if((e.response.body||e.response._bodyInit)&&!L.has(e.response.status)&&e.options.method!=="HEAD"){const p=(e.options.parseResponse?"json":e.options.responseType)||z(e.response.headers.get("content-type")||"");switch(p){case"json":{const g=await e.response.text(),$=e.options.parseResponse||C;e.response._data=$(g);break}case"stream":{e.response._data=e.response.body||e.response._bodyInit;break}default:e.response._data=await e.response[p]()}}return e.options.onResponse&&await S(e,e.options.onResponse),!e.options.ignoreResponseError&&e.response.status>=400&&e.response.status<600?(e.options.onResponseError&&await S(e,e.options.onResponseError),await f(e)):e.response},m=async function(u,h){return(await c(u,h))._data};return m.raw=c,m.native=(...a)=>r(...a),m.create=(a={},u={})=>q({...o,...u,defaults:{...o.defaults,...u.defaults,...a}}),m}const k=function(){if(typeof globalThis<"u")return globalThis;if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")}(),X=k.fetch?(...o)=>k.fetch(...o):()=>Promise.reject(new Error("[ofetch] global.fetch is not supported!")),G=k.Headers,K=k.AbortController,Q=q({fetch:X,Headers:G,AbortController:K}),V=Q.create({baseURL:"/api",async onRequest({options:o}){const r=A("accessToken").value;console.log("🔐 $api onRequest - Token:",r?"EXISTS":"NOT FOUND"),r?(o.headers||(o.headers=new Headers),o.headers instanceof Headers?o.headers.set("Authorization",`Bearer ${r}`):o.headers.Authorization=`Bearer ${r}`,console.log("✅ $api - Authorization header added")):console.log("❌ $api - No access token found")}}),re=()=>{const o=b(!1),r=b(null),t=b(null),d=b(null),f=b(null),c=b([]),m=async()=>{o.value=!0;try{const s=(await T.get("/api/hpp/dashboard")).data;if(s.success)return f.value=s.data,s.data;throw new Error(s.message||"Failed to get HPP dashboard")}catch(n){throw console.error("Error getting HPP dashboard:",n),n}finally{o.value=!1}},a=async(n,s="current")=>{o.value=!0;try{console.log("🔍 HPP Breakdown - Product ID:",n,"Method:",s),console.log("🔍 Access Token:",A("accessToken").value?"EXISTS":"NOT FOUND");const P=(await T.get(`/api/hpp/products/${n}/breakdown?method=${s}`)).data;if(P.success)return r.value=P.data.hpp_breakdown,P.data;throw new Error(P.message||"Failed to get HPP breakdown")}catch(i){throw console.error("❌ Error getting HPP breakdown:",i),i}finally{o.value=!1}},u=async(n,s)=>{o.value=!0;try{console.log("🔄 Updating HPP for product:",n,"with method:",s);const i=localStorage.getItem("token"),l=(await T.post(`/api/hpp/products/${n}/update`,{method:s},{headers:{Authorization:`Bearer ${i}`,Accept:"application/json","Content-Type":"application/json"}})).data;if(l.success)return console.log(`✅ HPP updated successfully for ${l.data.product_name}`),l.data;throw new Error(l.message||"Failed to update HPP")}catch(i){throw console.error("❌ Error updating HPP:",i),i}finally{o.value=!1}},h=async n=>{o.value=!0;try{const i=(await T.get(`/api/hpp/products/${n}/compare-methods`)).data;if(i.success)return t.value=i.data,i.data;throw new Error(i.message||"Failed to compare HPP methods")}catch(s){throw console.error("Error comparing HPP methods:",s),s}finally{o.value=!1}},e=async(n,s)=>{o.value=!0;try{console.log("🔄 Calculating suggested price for product:",n,"with markup:",s);const i=localStorage.getItem("token"),l=(await T.post(`/api/hpp/products/${n}/suggested-price`,{markup_percentage:s},{headers:{Authorization:`Bearer ${i}`,Accept:"application/json","Content-Type":"application/json"}})).data;if(l.success)return d.value=l.data,console.log("✅ Suggested price calculated:",l.data),l.data;throw new Error(l.message||"Failed to calculate suggested price")}catch(i){throw console.error("❌ Error calculating suggested price:",i),i}finally{o.value=!1}},y=async(n,s,i,P=!0)=>{o.value=!0;try{console.log("🔄 Updating price from HPP for product:",n);const l=localStorage.getItem("token"),E=(await T.post(`/api/hpp/products/${n}/update-price`,{method:s,markup_percentage:i,update_cost:P},{headers:{Authorization:`Bearer ${l}`,Accept:"application/json","Content-Type":"application/json"}})).data;if(E.success)return console.log(`✅ Price updated successfully for ${E.data.product_name}`),E;throw new Error(E.message||"Failed to update price from HPP")}catch(l){throw console.error("❌ Error updating price from HPP:",l),l}finally{o.value=!1}},w=async n=>{o.value=!0;try{const s=await V("/hpp/bulk-update",{method:"POST",body:{method:n}});if(s.success)return c.value=s.data.details,console.log(`Bulk HPP update completed for ${s.data.updated_products} products`),s.data;throw new Error(s.message||"Failed to bulk update HPP")}catch(s){throw console.error("Error bulk updating HPP:",s),s}finally{o.value=!1}},p=H(()=>r.value!==null),g=H(()=>t.value!==null),$=H(()=>d.value!==null),R=H(()=>f.value!==null);return{loading:o,currentHPPBreakdown:r,currentHPPComparison:t,currentHPPSuggestion:d,hppDashboard:f,bulkUpdateResults:c,getHPPDashboard:m,getProductHPPBreakdown:a,updateProductHPP:u,compareHPPMethods:h,calculateSuggestedPrice:e,updatePriceFromHPP:y,bulkUpdateHPP:w,hasHPPData:p,hasComparisonData:g,hasSuggestionData:$,hasDashboardData:R,formatCurrency:n=>new Intl.NumberFormat("id-ID",{style:"currency",currency:"IDR",minimumFractionDigits:0}).format(n),calculateProfitPercentage:(n,s)=>s===0?0:(n-s)/s*100,resetStates:()=>{r.value=null,t.value=null,d.value=null,c.value=[]}}};export{re as u};
